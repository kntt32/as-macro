import core;

pub template RawVec(T, A) {
    impl Slice($(T));

    pub struct Vec_$(T) {
        slice: Slice_$(T),
        capacity: i64,
    };

    pub as new(out self: Vec_$(T)@mem) {
        self.slice.empty();
        self.capacity = 0;
    };

    pub as push(inout self: Vec_$(T)@mem, in value: $(T)@reg+mem+imm) {
        let self_len: i64@auto;
        self.slice.len(self_len);

        let new_capacity: i64@auto = self_len;
        new_capacity += 1;
        self.reserve(new_capacity);

        let self_ptr: *$(T)@auto;
        self.slice.as_ptr(self_ptr);

        let value_index: i64@auto = self_len;
        self_len += 1;
        self.slice.from(self_ptr, self_len);

        let ptr: *$(T)@auto;
        self.slice.index(value_index, ptr);
        *ptr = value;
    };

    pub as len(in self: Vec_$(T)@mem, out len: i64@reg+mem) {
        self.slice.len(len);
    };

    pub as capacity(in self: Vec_$(T)@mem, out capacity: i64@reg+mem) {
        capacity = self.capacity;
    };

    as reserve(inout self: Vec_$(T)@mem, in capacity: i64@reg+mem+imm) {
        let flag: bool@auto;

        if(flag.gt(capacity, self.capacity)) {
            let self_len: i64@auto;
            self.slice.len(self_len);

            let new_capacity: i64@auto = self.capacity;
            if(flag.eq(new_capacity, 0)) {
                new_capacity = 4;
            }else {
                new_capacity += new_capacity;
            };
            
            new_capacity.max(capacity);

            let new_memsize: i64@auto = new_capacity;
            new_memsize.imul(sizeof($(T)));

            let new_ptr: *i8@auto;
            $(A).alloc(new_memsize, new_ptr_mem);

            let old_memsize: i64@auto;
            self.slice.len(old_memsize);
            old_memsize.imul(sizeof($(T)));
            
            let old_ptr: *void@auto;
            self.slice.as_ptr(old_ptr);
            
            memcpy(new_ptr, old_ptr, old_memsize);

            $(A).dealloc(old_ptr);

            self.slice.from(new_ptr, self_len);
            self.capacity = new_capacity;
        }
    };

    pub as drop(inout self: Vec_$(T)@mem) {
        let self_len: i64@auto;
        self.slice.len(self_len);

        let object_ptr: *$(T)@auto;
        
        for((let i: i64@auto = 0; let flag: bool@auto); flag.lt(i, self_len); ++i) {
           self.slice.index(i, object_ptr_rax);
           (*object_ptr_rax).drop();
        };

        let slice_ptr: *$(T)@auto;
        self.slice.as_ptr(slice_ptr);
        $(A).dealloc(slice_ptr);
    };
};

