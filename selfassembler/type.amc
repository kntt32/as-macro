import std;
import std.parser;
import std.vec;
import error;

pub struct PartialType {
    name: String,
    public: bool,
    parser: Parser,
};

pub as mov(out dst: PartialType@mem, in src: PartialType@mem) {
    dst.name = src.name;
    dst.public = src.public;
    dst.parser = src.parser;
};

impl Vec(PartialType);
/*
pub as get(out self: *PartialType@reg+mem, in name: Str@mem, in partial_types: Vec_PartialType@mem, out exist: bool@reg+mem) {
    let flag: bool@auto;
    let len: u64@auto;
    partial_types.len(len);
    let partial_type: *PartialType@auto;
    let str: Str@mem;

    for(let i: u64@auto = 0; flag.lt(i, len); ++i) {
        partial_types.index(i, partial_type);
        partial_type.name.as_str(str);
        if(flag.eq(name, str)) {
            self = partial_type;
            i = len;
        };
    };
};
*/
pub as parse(inout self: Parser@mem, out partial_type: PartialType@mem, out exist: bool@reg+mem) {
    let self_copy: Parser@stack = self;
    let str: Str@stack;
    self_copy.parse_keyword(str.from("pub"), partial_type.public);

    let flag: bool@auto;
    do(exist) {
        try self_copy.parse_ident(str, exist);
        try self_copy.parse_ident(str, exist);

        partial_type.name.from(str);

        partial_type.parser = self;
    };
};

pub as drop(inout self: PartialType@mem) {
    self.name.drop();
};

pub template Display_PartialType(Formatter) {
    impl Display($(Formatter));
    impl Display_String($(Formatter));
    impl Display_Parser($(Formatter));

    pub as display(inout self: $(Formatter)@mem, in object: PartialType@mem) {
        let str: Str@stack;
        self.write(str.from("PartialType { name: \""));
        self.display(object.name);
        self.write(str.from("\", public: "));
        self.display(object.public);
        self.write(str.from(", parser: "));
        self.display(object.parser);
        self.write(str.from(" }"));
    };
};

pub struct StructMember {
    name: String,
    type: Parser,
    offset: u64,
};

pub template Display_StructMember(Formatter) {
    impl Display($(Formatter));
    impl Display_String($(Formatter));
    impl Display_Parser($(Formatter));

    pub as display(inout self: $(Formatter)@mem, in value: StructMember@mem) {
        let str: Str@stack;
        self.write(str.from("StructMember { name: "));
        self.display(value.name);
        self.write(str.from(", type: "));
        self.display(value.type);
        self.write(str.from(", offset: "));
        self.display(value.offset);
        self.display(str.from(" }"));
    };
};

impl Vec(StructMember);

pub as mov(out dst: StructMember@mem, in src: StructMember@mem) {
    dst.name = src.name;
    dst.type = src.type;
    dst.offset = src.offset;
};

as align(inout offset: u64@reg+mem, in align: u64@reg+mem+imm) {
    offset += align;
    offset -= 1;
    offset.div(align);
    offset.imul(align);
};

pub as parse(inout self: Parser@mem, out struct_member: StructMember@mem, inout size: u64@reg+mem, inout align: u64@reg+mem, in partial_types: Vec_PartialType@mem, out error: Error@mem, out exist: bool@reg+mem) {
    // name: type
    let str: Str@stack;
    let name: Str@stack;
    let flag: bool@auto;

    do(exist) {
        self.parse_ident(name, exist);
        try if(exist.not()) {
            error.new(self.offset, str.from("expected name"));
            exist = false;
        }else {
            exist.not();
        };
        
        self.parse_symbol_char(':', exist);
        try if(exist.not()) {
            error.new(self.offset, str.from("expected symbol \":\""));
            exist = false;
        }else {
            exist.not();
        };

        struct_member.type = self;

        let type: defer Type@stack;
        try self.parse_wrapped(type, partial_types, error, exist);

        if(flag.gt(type.align, align)) {
            align = type.align;
        };
        size.align(type.align);

        struct_member.name.from(name);
        struct_member.offset = size;

        size += type.size;
    };
};

impl Display_Parser(Out);

pub as parse(inout self: Parser@mem, inout struct_members: Vec_StructMember@mem, out size: u64@reg+mem, out align: u64@reg+mem, in partial_types: Vec_PartialType@mem, out error: Error@mem, out exist: bool@reg+mem) {
    
    exist = true;
    size = 0;
    align = 1;

    let flag: bool@auto = true;
    let struct_member: StructMember@stack;
    let member_parser: Parser@stack;

    while(flag.is_empty(self).not().and(exist)) {
        self.split(',', member_parser);
        member_parser.parse(struct_member, size, align, partial_types, error, exist);
        if(exist) {
            struct_members.push(struct_member);
        };
    };
};

pub as drop(self: StructMember@mem) {
    self.name.drop();
};

enum TypeClass {
    Integer, Struct, Enum, Union, Array, Addr, FnAddr
};

pub template Display_TypeClass(Formatter) {
    pub as display(inout self:$(Formatter)@mem, in value: TypeClass@reg+mem+imm) {
        let str: Str@stack;
        self.write(str.from("TypeClass."));
        switch(value) {
            TypeClass.Integer {
                self.write(str.from("Integer"));
            };
            TypeClass.Struct {
                self.write(str.from("Struct"));
            };
            TypeClass.Enum {
                self.write(str.from("Enum"));
            };
            TypeClass.Union {
                self.write(str.from("Union"));
            };
            TypeClass.Array {
                self.write(str.from("Array"));
            };
            TypeClass.Addr {
                self.write(str.from("Addr"));
            };
            TypeClass.FnAddr {
                self.write(str.from("FnAddr"));
            };
        };
    };
};

union TypeBody {
    integer: void,
    struct: Vec_StructMember,
};

pub struct Type {
    name: String,
    path: String,
    public: bool,
    class: TypeClass,
    body: TypeBody,
    size: u64,
    align: u64,
};

impl Vec(PartialType);

pub as drop(self: Type@mem) {
    self.name.drop();
    self.path.drop();
    switch(self.class) {
        TypeClass.Integer {};
        TypeClass.Struct {
            self.body.struct.drop();
        };
        default {
            todo("todo in Type.drop()");
        };
    };
};

pub template Display_Type(Formatter) {
    impl Display_String($(Formatter));
    impl Display($(Formatter));
    impl Display_TypeClass($(Formatter));
    impl Display_StructMember($(Formatter));
    impl Display_Vec($(Formatter), StructMember);

    pub as display(inout self: $(Formatter)@mem, in value: Type@mem) {
        let str: Str@stack;
        self.write(str.from("Type { name: "));
        self.display(value.name);
        self.write(str.from(", path: "));
        self.display(value.path);
        self.write(str.from(", public: "));
        self.display(value.public);
        self.write(str.from(", class: "));
        self.display(value.class);
        self.write(str.from(", body: "));
        switch(value.class) {
            TypeClass.Integer {
                self.write(str.from("None"));
            };
            TypeClass.Struct {
                self.display(value.body.struct);
            };
            default {
                todo("todo in display_type template");
            };
        };
        self.write(str.from(", size: "));
        self.display(value.size);
        self.write(str.from(", align: "));
        self.display(value.align);
        self.write(str.from(" }"));
    };
};

pub as parse_wrapped(inout self: Parser@mem, out type: Type@mem, in partial_types: Vec_PartialType@mem, out error: Error@mem, out exist: bool@reg+mem) {
    let self_addr: *Parser@auto;
    let type_addr: *Type@auto;
    let partial_types_addr: *Vec_PartialType@auto;
    let error_addr: *Error@auto;
    let exist_stack: bool@stack;
    !DEBUG_DEBUG;
    let exist_addr: *bool@auto;
    self_addr =& self;
    type_addr =& type;
    partial_types_addr =& partial_types;
    error_addr =& error;
    exist_addr =& exist_stack;

    {
        let self_addr_rdi: *Parser@rdi = self_addr;
        let type_addr_rsi: *Type@rsi = type_addr;
        let partial_types_addr_rbx: *Vec_PartialType@rbx = partial_types_addr;
        let error_addr_rdx: *Error@rdx = error_addr;
        let exist_addr_rax: *bool@rax = exist_addr;
        Type_parse_fn(self_addr_rdi, type_addr_rsi, partial_types_addr_rbx, error_addr_rdx, exist_addr_rax);
    };

    exist = exist_stack;
};

fn Type_parse_fn(inout self: *Parser@rdi, out type: *Type@rsi, in partial_types: *Vec_PartialType@rbx, out error: *Error@rdx, out exist: *bool@rax) {
    parse(*self, *type, *partial_types, *error, *exist);
};

pub as parse(inout self: Parser@mem, out type: Type@mem, in partial_types: Vec_PartialType@mem, out error: Error@mem, out exist: bool@reg+mem) {
    let str: Str@stack;

    if((self.parse_keyword(str.from("i64"), exist); exist)) {
        type.name.from(str.from("i64"));
        type.path.new();
        type.public = true;
        type.class = TypeClass.Integer;
        type.size = 8;
        type.align = 8;
        exist = true;
    }else if((self.parse_ident(str, exist); exist)) {
        let flag: bool@auto;
        let len: u64@auto;
        partial_types.len(len);
        let partial_type: *PartialType@auto;
        let partial_type_name: Str@stack;

        exist = false;
        for(let i: u64@auto = 0; flag.lt(i, len); ++i) {
            partial_types.index(i, partial_type);

            (*partial_type).name.as_str(partial_type_name);
            if(flag.eq(partial_type_name, str)) {
                type.from(*partial_type, partial_types, error, exist);
                i = len;
            };
        };

        if(exist.not()) {
            exist = false;
            error.new(self.offset, str.from("undefined type"));
        };
    }else {
        exist = false;
        error.new(self.offset, str.from("expected type"));
    };
};

pub as from(out self: Type@mem, in partial_type: PartialType@mem, in partial_types: Vec_PartialType@mem, out error: Error@mem, out exist: bool@reg+mem) {
    let parser: Parser@stack = partial_type.parser;
    let str: Str@stack;
    let flag: bool@auto;

    if(partial_type.public) {
        parser.parse_keyword(str.from("pub"), flag);
    };

    if((parser.parse_keyword(str.from("struct"), flag); flag)) {
        self.from_struct(parser, partial_type, partial_types, error, exist);
    }else {
        let string: String@stack;
        string.from(str.from("unknown type class"));
        error.new(parser.offset, string);
        exist = false;
    };
};

as from_struct(out self: Type@mem, inout parser: Parser@mem, in partial_type: PartialType@mem, in partial_types: Vec_PartialType@mem, out error: Error@mem, out exist: bool@reg+mem) {
    let str: Str@stack;
    let struct_elements: Vec_StructMember@stack;
    struct_elements.new();

    parser.parse_ident(str, exist);
    
    do(exist) {
        let block_parser: Parser@stack;
        parser.parse_block(block_parser, exist); 
        try if(exist.not()) {
            error.new(parser.offset, str.from("expected symbol {"));
            exist = false;
        }else {
            exist.not();
        };

        try block_parser.parse(struct_elements, self.size, self.align, partial_types, error, exist);

        exist.is_empty(parser);
        try if(exist.not()) {
            error.new(parser.offset, str.from("unexpected token"));
            exist = false;
        }else {
            exist.not();
        };

        partial_type.name.clone(self.name);
        self.path.from(parser.offset.path);
        self.public = partial_type.public;
        self.class = TypeClass.Struct;
        self.body.struct = struct_elements;
    }catch {
        struct_elements.drop();
        exist = false;
    };
};







