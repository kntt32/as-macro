import std;
import std.parser;
import core.drop;

pub enum Register {
    Rip = -1,
    Rax = 0,
    Rcx, Rdx, Rbx, Rsp, Rbp, Rsi, Rdi,
    R8, R9, R10, R11, R12, R13, R14, R15
};

impl DefaultDrop(Register);

struct RegisterTable {
    register: Register,
    str: [char; 4],
};

static REGISTER_TABLE: [RegisterTable; 17] = [
    RegisterTable { register: Register.Rip, str: "rip" },
    RegisterTable { register: Register.Rax, str: "rax" },
    RegisterTable { register: Register.Rcx, str: "rcx" },
    RegisterTable { register: Register.Rdx, str: "rdx" },
    RegisterTable { register: Register.Rbx, str: "rbx" },
    RegisterTable { register: Register.Rsp, str: "rsp" },
    RegisterTable { register: Register.Rbp, str: "rbp" },
    RegisterTable { register: Register.Rsi, str: "rsi" },
    RegisterTable { register: Register.Rdi, str: "rdi" },
    RegisterTable { register: Register.R8, str: "r8" },
    RegisterTable { register: Register.R9, str: "r9" },
    RegisterTable { register: Register.R10, str: "r10" },
    RegisterTable { register: Register.R11, str: "r11" },
    RegisterTable { register: Register.R12, str: "r12" },
    RegisterTable { register: Register.R13, str: "r13" },
    RegisterTable { register: Register.R14, str: "r14" },
    RegisterTable { register: Register.R15, str: "r15" },
];

pub as parse(inout self: Parser@mem, out register: Register@reg+mem, out exist: bool@reg+mem) {
    let register_table: *RegisterTable@auto;
    register_table =& REGISTER_TABLE;
    let flag: bool@auto;
    let for_flag: bool@auto = true;

    exist = false;

    let str: Str@stack;
    for(let i: u64@auto; flag.lt(i, 17).and(for_flag); ++i) {
        str.from((*register_table).str);
        if((self.parse_keyword(str, exist); exist)) {
            register = (*register_table).register;
            exist = true;
            for_flag = false;
        };
        register_table += sizeof(RegisterTable);
    };
};

pub template Display_Register(Formatter) {
    pub as display(inout self: $(Formatter)@mem, in value: Register@reg+mem+imm) {
        let register_table: *RegisterTable@auto;
        register_table =& REGISTER_TABLE;
        let flag: bool@auto;
        let for_flag: bool@auto = true;

        for(let i: u64@auto = 0; flag.lt(i, 17).and(for_flag); ++i) {
            if(flag.eq((*register_table).register, value)) {
                let str: Str@stack;
                self.write(str.from((*register_table).str));
                for_flag = false;
            };
            register_table += sizeof(RegisterTable);
        };
    };
};

