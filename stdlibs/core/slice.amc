import core;
import panic;

pub template Slice(T) {
    pub struct Slice_$(T) {
        addr: *$(T),
        len: u64,
    };

    pub as eq(out flag: bool@reg+mem, in left: Slice_$(T)@mem, in right: Slice_$(T)@mem) {
        if(flag.eq(left.len, right.len)) {
            let break_flag: bool@auto = true;

            for(let i: u64@auto = 0; flag.lt(i, left.len).and(break_flag); ++i) {
                let left_addr: *$(T)@auto;
                let right_addr: *$(T)@auto;
                left.index(i, left_addr);
                right.index(i, right_addr);

                if(flag.eq(*left_addr, *right_addr).not()) {
                    break_flag = false;
                };
                flag.not();
            };

            flag = break_flag;
        };
    };

    pub as mov(out dst: Slice_$(T)@mem, out src: Slice_$(T)@mem) {
        dst.addr = src.addr;
        dst.len = src.len;
    };

    pub as from(out self: Slice_$(T)@mem, in addr: *$(T)@reg+mem, in len: u64@reg+mem+imm) {
        self.addr = addr;
        self.len = len;
    };

    pub as is_empty(out flag: bool@reg+mem, in self: Slice_$(T)@mem+imm) {
        flag.eq(self.len, 0);
    };

    pub as empty(out self: Slice_$(T)@mem) {
        self.addr = null;
        self.len = 0;
    };
    
    pub as index(in self: Slice_$(T)@mem, in index: u64@reg+mem+imm, out addr: *$(T)@reg+mem) {
        panic_ge(index, self.len, "Slice:index: out of rangea");
        let addr_auto: *$(T)@auto = sizeof($(T));
        addr_auto.imul(index);
        addr_auto += self.addr;
        addr = addr_auto;
    };

    pub as len(in self: Slice_$(T)@mem, out len: u64@reg+mem) {
        len = self.len;
    };

    pub as as_addr(in self: Slice_$(T)@mem, out addr: *$(T)@reg+mem) {
        addr = self.addr;
    };

    pub as slice(in self: Slice_$(T)@mem, in start: u64@reg+mem+imm, in len: u64@reg+mem+imm, out buff: Slice_$(T)@mem) {
        let flag: bool@auto;
        if(flag.neq(len, 0)) {
            panic_le(self.len, start, "Slice:slice: out of rangeb");
            let origin_len: u64@auto = len;
            origin_len += start;
            panic_gt(origin_len, self.len, "Slice:slice: out of rangec");

            buff.addr = sizeof($(T));
            buff.addr.imul(start);
            buff.addr += self.addr;

            buff.len = len;
        }else {
            buff.addr = start;
            buff.addr.imul(sizeof($(T)));
            buff.addr += self.addr;
            buff.len = 0;
        };
    };
};

