import std;
import core.option;
import std.string;
import std.parser;
import register;

impl Option(String);

pub struct Memory {
    base: Register,
    label: Option_String,
    disp: i32,
};

pub as mov(out dst: Memory@mem, in src: Memory@mem) {
    dst.base = src.base;
    dst.label = src.label;
    dst.disp = src.disp;
};

pub as drop(inout self: Memory@mem) {
    self.label.drop();
};

pub template Display_Memory(Formatter) {
    impl Display_Option($(Formatter), String);

    pub as display(inout self: $(Formatter)@mem, in value: Memory@mem) {
        let str: Str@stack;
        self.write(str.from("Memory { base: "));
        self.display(value.base);
        self.write(str.from(", label: "));
        self.display(value.label);
        self.write(str.from(", disp: "));
        self.display(value.disp);
        self.write(str.from(" }"));
    };
};

pub struct Imm {
    label: Option_String,
    value: u64,
};

pub as mov(out dst: Imm@mem, in src: Imm@mem) {
    dst.label = src.label;
    dst.value = src.value;
};

pub as drop(inout self: Imm@mem) {
    self.label.drop();
};

pub template Display_Imm(Formatter) {
    pub as display(inout self: $(Formatter)@mem, in value: Imm@mem) {
        let str: Str@stack;
        self.write(str.from("Imm { label: "));
        self.display(value.label);
        self.write(str.from(", value: "));
        self.display(value.value);
        self.write(str.from(" }"));
    };
};

enum StorageClass {
    Register,
    Memory,
    Imm,
};

union StorageBody {
    register: Register,
    memory: Memory,
    imm: Imm,
};

pub struct Storage {
    class: StorageClass,
    body: StorageBody,
};

impl Option(Register);

pub as mov(out dst: Storage@mem, in src: Storage@mem) {
    dst.class = src.class;
    switch(self.class) {
        StorageClass.Register {
            self.body.register = src.body.register;
        };
        StorageClass.Memory {
            self.body.memory = src.body.memory;
        };
        StorageClass.Imm {
            self.body.imm = src.body.imm;
        };
    };
};

pub as parse(inout parser: Parser@mem, in auto_reg: Option_Register@mem, out storage: Storage@mem, out exist: bool@reg+mem) {
    let str: Str@stack;
    let register: Register@auto;
    let flag: bool@auto;

    if((parser.parse_keyword(str.from("stack"), exist); exist)) {
        storage.class = StorageClass.Memory;
        let memory: Memory@stack;
        memory.base = Register.Rsp;
        memory.label.none();
        memory.disp = 0;
        storage.body.memory = memory;
    }else if((parser.parse(register, exist); exist)) {
        storage.class = StorageClass.Register;
        storage.body.register = register;
    }else if((auto_reg.is_some(flag); flag).and((parser.parse_keyword(str.from("auto"), exist); exist))) {
        storage.class = StorageClass.Register;
        storage.body.register = register;
    }else {
        exist = false;
    };
};

pub as drop(inout self: Storage@mem) {
    switch(self.class) {
        StorageClass.Register {
            self.body.register.drop();
        };
        StorageClass.Memory {
            self.body.memory.drop();
        };
        StorageClass.Imm {
            self.body.imm.drop();
        };
    };
};

pub template Display_Storage(Formatter) {
    impl Display_Register($(Formatter));
    impl Display_Memory($(Formatter));
    impl Display_Imm($(Formatter));

    pub as display(inout self: $(Formatter)@mem, in value: Storage@mem) {
        let str: Str@stack;
        self.write(str.from("Storage { "));

        switch(value.class) {
            StorageClass.Register {
                self.display(value.body.register);
            };
            StorageClass.Memory {
                self.display(value.body.memory);
            };
            StorageClass.Imm {
                self.display(value.body.imm);
            };
        };

        self.write(str.from(" }"));
    };
};

